
@article{boncz_mil_1999,
	title = {{MIL} {Primitives} for {Querying} a {Fragmented} {World}},
	volume = {8},
	issn = {1066-8888},
	url = {https://doi.org/10.1007/s007780050076},
	doi = {10.1007/s007780050076},
	abstract = {In query-intensive database application areas, like decision support and data mining, systems that use vertical fragmentation have a significant performance advantage. In order to support relational or object oriented applications on top of such a fragmented data model, a flexible yet powerful intermediate language is needed. This problem has been successfully tackled in Monet, a modern extensible database kernel developed by our group. We focus on the design choices made in the Monet interpreter language (MIL), its algebraic query language, and outline how its concept of tactical optimization enhances and simplifies the optimization of complex queries. Finally, we summarize the experience gained in Monet by creating a highly efficient implementation of MIL.},
	number = {2},
	journal = {The VLDB Journal},
	author = {Boncz, Peter A. and Kersten, Martin L.},
	month = oct,
	year = {1999},
	note = {Place: Berlin, Heidelberg
Publisher: Springer-Verlag},
	keywords = {Database systems, Main-memory techniques, Query languages, Query optimization, Vertical fragmentation},
	pages = {101--119},
}

@article{copeland_decomposition_1985,
	title = {A {Decomposition} {Storage} {Model}},
	volume = {14},
	issn = {0163-5808},
	url = {https://doi.org/10.1145/971699.318923},
	doi = {10.1145/971699.318923},
	number = {4},
	journal = {SIGMOD Rec.},
	author = {Copeland, George P. and Khoshafian, Setrag N.},
	month = may,
	year = {1985},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {268--279},
	file = {ADecompositionStorageModel.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\ADecompositionStorageModel.pdf:application/pdf},
}

@inproceedings{gawade_adaptive_2016,
	title = {Adaptive query parallelization in multi-core column stores},
	url = {https://api.semanticscholar.org/CorpusID:642159},
	booktitle = {International {Conference} on {Extending} {Database} {Technology}},
	author = {Gawade, Mrunal and Kersten, Martin L.},
	month = mar,
	year = {2016},
}

@incollection{svensson_emerging_2010,
	address = {Boca Raton, FL},
	title = {Emerging database systems in support of scientific data},
	url = {https://ir.cwi.nl/pub/14982/14982B.pdf},
	urldate = {2023-12-26},
	booktitle = {Scientific {Data} {Management}: {Challenges}, {Technology}, and {Deployment}},
	publisher = {Chapman \& Hall/CRC, Taylor and Francis Group, LLC},
	author = {Svensson, Per and Boncz, Peter A. and Ivanova, Milena and Kersten, Martin L. and Nes, Niels and Rotem, Doron},
	month = jan,
	year = {2010},
	note = {[Author Manuscript]},
	pages = {235--277},
	file = {EmergingVertical.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\EmergingVertical.pdf:application/pdf},
}

@article{abadi_design_2012,
	title = {The {Design} and {Implementation} of {Modern} {Column}-{Oriented} {Database} {Systems}},
	volume = {5},
	issn = {1931-7883, 1931-7891},
	url = {http://www.nowpublishers.com/articles/foundations-and-trends-in-databases/DBS-024},
	doi = {10.1561/1900000024},
	language = {en},
	number = {3},
	urldate = {2023-12-26},
	journal = {Foundations and Trends® in Databases},
	author = {Abadi, Daniel},
	year = {2012},
	pages = {197--280},
	file = {columnstoresfntdbs.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\columnstoresfntdbs.pdf:application/pdf},
}

@inproceedings{cole_optimization_1994,
	address = {New York, NY, USA},
	series = {{SIGMOD} '94},
	title = {Optimization of {Dynamic} {Query} {Evaluation} {Plans}},
	isbn = {0-89791-639-5},
	url = {https://doi.org/10.1145/191839.191872},
	doi = {10.1145/191839.191872},
	abstract = {Traditional query optimizers assume accurate knowledge of run-time parameters such as selectivities and resource availability during plan optimization, i.e., at compile time. In reality, however, this assumption is often not justified. Therefore, the “static” plans produced by traditional optimizers may not be optimal for many of their actual run-time invocations. Instead, we propose a novel optimization model that assigns the bulk of the optimization effort to compile-time and delays carefully selected optimization decisions until run-time. Our previous work defined the run-time primitives, “dynamic plans” using “choose-plan” operators, for executing such delayed decisions, but did not solve the problem of constructing dynamic plans at compile-time. The present paper introduces techniques that solve this problem. Experience with a working prototype optimizer demonstrates (i) that the additional optimization and start-up overhead of dynamic plans compared to static plans is dominated by their advantage at run-time, (ii) that dynamic plans are as robust as the “brute-force” remedy of run-time optimization, i.e., dynamic plans maintain their optimality even if parameters change between compile-time and run-time, and (iii) that the start-up overhead of dynamic plans is significantly less than the time required for complete optimization at run-time. In other words, our proposed techniques are superior to both techniques considered to-date, namely compile-time optimization into a single static plan as well as run-time optimization. Finally, we believe that the concepts and technology described can be transferred to commercial query optimizers in order to improve the performance of embedded queries with host variables in the query predicate and to adapt to run-time system loads unpredictable at compile time.},
	urldate = {2023-12-31},
	booktitle = {Proceedings of the 1994 {ACM} {SIGMOD} {International} {Conference} on {Management} of {Data}},
	publisher = {Association for Computing Machinery},
	author = {Cole, Richard L. and Graefe, Goetz},
	year = {1994},
	note = {event-place: Minneapolis, Minnesota, USA},
	pages = {150--160},
}

@article{graefe_query_1993,
	title = {Query {Evaluation} {Techniques} for {Large} {Databases}},
	volume = {25},
	issn = {0360-0300},
	url = {https://doi.org/10.1145/152610.152611},
	doi = {10.1145/152610.152611},
	abstract = {Database management systems will continue to manage large data volumes. Thus, efficient algorithms for accessing and manipulating large sets and sequences will be required to provide acceptable performance. The advent of object-oriented and extensible database systems will not solve this problem. On the contrary, modern data models exacerbate the problem: In order to manipulate large sets of complex objects as efficiently as today's database systems manipulate simple records, query-processing algorithms and software will become more complex, and a solid understanding of algorithm and architectural issues is essential for the designer of database management software.This survey provides a foundation for the design and implementation of query execution facilities in new database management systems. It describes a wide array of practical query evaluation techniques for both relational and postrelational database systems, including iterative execution of complex query evaluation plans, the duality of sort- and hash-based set-matching algorithms, types of parallel query execution and their implementation, and special operators for emerging database application domains.},
	number = {2},
	urldate = {2023-12-31},
	journal = {ACM Comput. Surv.},
	author = {Graefe, Goetz},
	month = jun,
	year = {1993},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {complex query evaluation plans, dynamic query evaluation plans, extensible database systems, iterators, object-oriented database systems, operator model of parallelization, parallel algorithms, relational database systems, set-matching algorithms, sort-hash duality},
	pages = {73--169},
}

@inproceedings{graefe_dynamic_1989,
	address = {New York, NY, USA},
	series = {{SIGMOD} '89},
	title = {Dynamic {Query} {Evaluation} {Plans}},
	isbn = {0-89791-317-5},
	url = {https://doi.org/10.1145/67544.66960},
	doi = {10.1145/67544.66960},
	abstract = {In most database systems, a query embedded in a program written in a conventional programming language is optimized when the program is compiled. The query optimizer must make assumptions about the values of the program variables that appear as constants in the query, the resources that can be committed to query evaluation, and the data in the database. The optimality of the resulting query evaluation plan depends on the validity of these assumptions. If a query evaluation plan is used repeatedly over an extended period of time, it is important to determine when reoptimization is necessary. Our work aims at developing criteria when reoptimization is required, how these criteria can be implemented efficiently, and how reoptimization can be avoided by using a new technique called dynamic query evaluation plans. We experimentally demonstrate the need for dynamic plans and outline modifications to the EXODUS optimizer generator required for creating dynamic query evaluation plans.},
	booktitle = {Proceedings of the 1989 {ACM} {SIGMOD} {International} {Conference} on {Management} of {Data}},
	publisher = {Association for Computing Machinery},
	author = {Graefe, G. and Ward, K.},
	year = {1989},
	note = {event-place: Portland, Oregon, USA},
	pages = {358--366},
}

@inproceedings{zukowski_vectorwise_2012,
	address = {Arlington, VA, USA},
	title = {Vectorwise: {A} {Vectorized} {Analytical} {DBMS}},
	isbn = {978-0-7695-4747-3 978-1-4673-0042-1},
	shorttitle = {Vectorwise},
	url = {http://ieeexplore.ieee.org/document/6228203/},
	doi = {10.1109/ICDE.2012.148},
	urldate = {2023-12-31},
	booktitle = {2012 {IEEE} 28th {International} {Conference} on {Data} {Engineering}},
	publisher = {IEEE},
	author = {Zukowski, Marcin and Van De Wiel, Mark and Boncz, Peter},
	month = apr,
	year = {2012},
	pages = {1349--1350},
	file = {Submitted Version:C\:\\Users\\henri\\Zotero\\storage\\8N68FH3H\\Zukowski et al. - 2012 - Vectorwise A Vectorized Analytical DBMS.pdf:application/pdf},
}

@inproceedings{raasveldt_duckdb_2019,
	address = {Amsterdam Netherlands},
	title = {{DuckDB}: an {Embeddable} {Analytical} {Database}},
	isbn = {978-1-4503-5643-5},
	shorttitle = {{DuckDB}},
	url = {https://dl.acm.org/doi/10.1145/3299869.3320212},
	doi = {10.1145/3299869.3320212},
	language = {en},
	urldate = {2023-12-31},
	booktitle = {Proceedings of the 2019 {International} {Conference} on {Management} of {Data}},
	publisher = {ACM},
	author = {Raasveldt, Mark and Mühleisen, Hannes},
	month = jun,
	year = {2019},
	pages = {1981--1984},
	file = {Full Text:C\:\\Users\\henri\\Zotero\\storage\\LVKR2H25\\Raasveldt and Mühleisen - 2019 - DuckDB an Embeddable Analytical Database.pdf:application/pdf},
}

@article{farber_sap_2012,
	title = {The {SAP} {HANA} {Database}–{An} {Architecture} {Overview}.},
	volume = {35},
	url = {https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=afda6470dd16dc0a865dbb6fc291e5806132379b},
	number = {1},
	urldate = {2023-12-31},
	journal = {IEEE Data Eng. Bull.},
	author = {Färber, Franz and May, Norman and Lehner, Wolfgang and Große, Philipp and Müller, Ingo and Rauhe, Hannes and Dees, Jonathan},
	year = {2012},
	note = {Publisher: Citeseer},
	pages = {28--33},
	file = {SAPHana.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\SAPHana.pdf:application/pdf},
}

@misc{boncz_data_2022,
	address = {Utrecht, Netherlands},
	title = {Data {Systems} {Research} at {CWI}},
	url = {https://docs.google.com/presentation/d/1lqf2ckpSiVc_7EgPafoSqcmzLVZvDHna_cACx4vWTSs/edit#slide=id.g12071bc6c72_0_0},
	language = {English},
	urldate = {2023-12-31},
	author = {Boncz, Peter},
	month = jun,
	year = {2022},
	file = {Data Systems Research at CWI (2023).pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\Data Systems Research at CWI (2023).pdf:application/pdf;Data Systems Research at CWI (2023).pptx:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\Data Systems Research at CWI (2023).pptx:application/vnd.openxmlformats-officedocument.presentationml.presentation},
}

@inproceedings{boncz_monetdbx100_2005,
	address = {Asilomar, USA},
	title = {{MonetDB}/{X100}: {Hyper}-{Pipelining} {Query} {Execution}},
	url = {https://ir.cwi.nl/pub/16497/16497B.pdf},
	urldate = {2023-12-31},
	booktitle = {Proceedings of the 2005 {CIDR} {Conference}},
	author = {Boncz, Peter A. and Zukowski, Marcin and Nes, Niels},
	year = {2005},
	note = {[Author Manuscript]},
	pages = {225--237},
	file = {MonetDBX100.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\MonetDBX100.pdf:application/pdf},
}

@inproceedings{boncz_drill_1998,
	address = {San Francisco, CA, USA},
	series = {{VLDB} '98},
	title = {The {Drill} {Down} {Benchmark}},
	isbn = {1-55860-566-5},
	url = {https://www.vldb.org/conf/1998/p628.pdf},
	urldate = {2023-12-26},
	booktitle = {Proceedings of the 24rd {International} {Conference} on {Very} {Large} {Data} {Bases}},
	publisher = {Morgan Kaufmann Publishers Inc.},
	author = {Boncz, Peter A. and Rühl, Tim and Kwakkel, Fred},
	year = {1998},
	pages = {628--632},
	file = {DrillDownBenchmark.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\DrillDownBenchmark.pdf:application/pdf},
}

@inproceedings{manegold_what_2000,
	address = {San Francisco, CA, USA},
	series = {{VLDB} '00},
	title = {What {Happens} {During} a {Join}? {Dissecting} {CPU} and {Memory} {Optimization} {Effects}},
	isbn = {1-55860-715-3},
	url = {https://ir.cwi.nl/pub/11168/11168B.pdf},
	urldate = {2023-12-26},
	booktitle = {Proceedings of the 26th {International} {Conference} on {Very} {Large} {Data} {Bases}},
	publisher = {Morgan Kaufmann Publishers Inc.},
	author = {Manegold, Stefan and Boncz, Peter A. and Kersten, Martin L.},
	year = {2000},
	note = {[Author Manuscript]},
	pages = {339--350},
	file = {WhatHappensDuringAJoin.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\WhatHappensDuringAJoin.pdf:application/pdf},
}

@inproceedings{manegold_multi-query_2000,
	address = {Berlin, Heidelberg},
	title = {A {Multi}-{Query} {Optimizer} for {Monet}},
	isbn = {978-3-540-45033-7},
	url = {https://api.semanticscholar.org/CorpusID:13640968},
	abstract = {Database systems allow for concurrent use of several applications (and query interfaces). Each application generates an “optimal” plan—a sequence of low-level database operators—for accessing the database. The queries posed by users through the same application can be optimized together using traditional multi-query optimization techniques. However, the commonalities among queries of different applications are not exploited.},
	urldate = {2023-12-26},
	booktitle = {Advances in {Databases}},
	publisher = {Springer Berlin Heidelberg},
	author = {Manegold, Stefan and Pellenkoft, Arjan and Kersten, Martin},
	editor = {Lings, Brian and Jeffery, Keith},
	year = {2000},
	pages = {36--50},
	file = {MultiQueryOptimizerForMonet.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\MultiQueryOptimizerForMonet.pdf:application/pdf},
}

@inproceedings{cornacchia_case_2004,
	address = {New York, NY, USA},
	series = {{CVDB} '04},
	title = {A {Case} {Study} on {Array} {Query} {Optimisation}},
	isbn = {1-58113-917-9},
	url = {https://doi.org/10.1145/1039470.1039476},
	doi = {10.1145/1039470.1039476},
	abstract = {The development of applications involving multi-dimensional data sets on top of a RDBMS raises several difficulties that are not directly related to the scientific problem being addressed. In particular, an additional effort is needed to solve the mismatch existing between the array-based data model typical of such computations and the set-based data model provided by the RDMBS. The RAM (Relational Array Mapping) system fills this gap, silently providing a mapping layer between the two data models. As expected though, a naive implementation of such an automatic translation cannot compete with the efficiency of queries written by an experienced programmer. In order to make RAM a valid alternative to expensive and time-consuming hand-written solutions, this performance gap should be reduced. We study a real-world application aimed at the ranking of multimedia collections to assess the impact of different implementation strategies. The result of this study provides an illustrative outlook for the development of generally applicable optimisation techniques.},
	urldate = {2023-12-26},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Computer} {Vision} {Meets} {Databases}},
	publisher = {Association for Computing Machinery},
	author = {Cornacchia, Roberto and van Ballegooij, Alex and de Vries, Arjen P.},
	year = {2004},
	note = {event-place: Paris, France},
	pages = {3--10},
}

@article{boncz_breaking_2008,
	title = {Breaking the {Memory} {Wall} in {MonetDB}},
	volume = {51},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/1409360.1409380},
	doi = {10.1145/1409360.1409380},
	abstract = {In the past decades, advances in speed of commodity CPUs have far outpaced advances in RAM latency. Main-memory access has therefore become a performance bottleneck for many computer applications; a phenomenon that is widely known as the "memory wall." In this paper, we report how research around the MonetDB database system has led to a redesign of database architecture in order to take advantage of modern hardware, and in particular to avoid hitting the memory wall. This encompasses (i) a redesign of the query execution model to better exploit pipelined CPU architectures and CPU instruction caches; (ii) the use of columnar rather than row-wise data storage to better exploit CPU data caches; (iii) the design of new cache-conscious query processing algorithms; and (iv) the design and automatic calibration of memory cost models to choose and tune these cache-conscious algorithms in the query optimizer.},
	number = {12},
	urldate = {2023-12-31},
	journal = {Commun. ACM},
	author = {Boncz, Peter A. and Kersten, Martin L. and Manegold, Stefan},
	month = dec,
	year = {2008},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {77--85},
	file = {BreakingTheMemoryWall.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\BreakingTheMemoryWall.pdf:application/pdf},
}

@unpublished{pavlo_lecture_2022,
	address = {Pittsburgh},
	type = {Lecture {Notes}},
	title = {Lecture \#11: {Joins} {Algorithms} of 15-445/645 {Database} {Systems} ({Fall} 2022)},
	url = {https://15445.courses.cs.cmu.edu/fall2022/notes/11-joins.pdf},
	urldate = {2024-01-04},
	author = {Pavlo, Andy},
	year = {2022},
	file = {11-joins.pdf:C\:\\Users\\henri\\Zotero\\storage\\6Q95KPFS\\11-joins.pdf:application/pdf},
}

@article{shapiro_join_1986,
	title = {Join {Processing} in {Database} {Systems} with {Large} {Main} {Memories}},
	volume = {11},
	issn = {0362-5915},
	url = {https://doi.org/10.1145/6314.6315},
	doi = {10.1145/6314.6315},
	abstract = {We study algorithms for computing the equijoin of two relations in a system with a standard architecture hut with large amounts of main memory. Our algorithms are especially efficient when the main memory available is a significant fraction of the size of one of the relations to he joined; but they can be applied whenever there is memory equal to approximately the square root of the size of one relation. We present a new algorithm which is a hybrid of two hash-based algorithms and which dominates the other algorithms we present, including sort-merge. Even in a virtual memory environment, the hybrid algorithm dominates all the others we study.Finally, we describe how three popular tools to increase the efficiency of joins, namely filters, Babb arrays, and semijoins, can he grafted onto any of our algorithms.},
	number = {3},
	urldate = {2024-01-04},
	journal = {ACM Trans. Database Syst.},
	author = {Shapiro, Leonard D.},
	month = aug,
	year = {1986},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {239--264},
	file = {JoinProcessingInSystemsWith.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\JoinProcessingInSystemsWith.pdf:application/pdf},
}

@inproceedings{klyuchikov_hybrid_2024,
	address = {New York, NY, USA},
	series = {{CODS}-{COMAD} '24},
	title = {Hybrid {Materialization} in a {Disk}-{Based} {Column}-{Store}},
	isbn = {9798400716348},
	url = {https://doi.org/10.1145/3632410.3632422},
	doi = {10.1145/3632410.3632422},
	abstract = {In column-oriented query processing, a materialization strategy determines when lightweight positions (row IDs) are translated into tuples. It is an important part of column-store architecture, since it defines the class of supported query plans, and, therefore, impacts overall system performance. In this paper, we continue investigating materialization strategies for a distributed disk-based column-store. We start by demonstrating cases of existing approaches fundamentally limiting resulting system performance. In order to address them, we propose a new model of hybrid materialization. The main feature of hybrid materialization is the ability to manipulate both positions and values at the same time. This way, the query engine can efficiently combine advantages of all the existing strategies and support a new class of query plans. Moreover, hybrid materialization enables the query engine to flexibly customize the materialization policy of individual attributes. We describe our vision of how hybrid materialization can be implemented in a columnar system. As an example, we use PosDB\&nbsp;— a distributed, disk-based column-store. We present necessary data structures, the internals of a hybrid operator, and describe the algebra of such operators. Based on this implementation, we evaluate performance of late, ultra-late, and hybrid materialization strategies in several scenarios based on TPC-H queries. Our experiments demonstrate that hybrid materialization is almost two times faster than its counterparts, while providing a more flexible query model.},
	urldate = {2024-01-04},
	booktitle = {Proceedings of the 7th {Joint} {International} {Conference} on {Data} {Science} \& {Management} of {Data} (11th {ACM} {IKDD} {CODS} and 29th {COMAD})},
	publisher = {Association for Computing Machinery},
	author = {Klyuchikov, Evgeniy and Polyntsov, Michael and Chizhov, Anton and Mikhailova, Elena and Chernishev, George},
	year = {2024},
	keywords = {Analytic workloads, Column-stores, Databases, Hybrid materialization, Late Materialization, Query engine, Query processing},
	pages = {164--172},
	file = {hybridMaterializationInADiskBasedColumnStore.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\hybridMaterializationInADiskBasedColumnStore.pdf:application/pdf},
}

@article{ivanova_parallel_2017,
	title = {Parallel processing of very large databases using distributed column indexes},
	volume = {43},
	issn = {1608-3261},
	url = {https://doi.org/10.1134/S0361768817030069},
	doi = {10.1134/S0361768817030069},
	abstract = {The development and investigation of efficient methods of parallel processing of very large databases using the columnar data representation designed for computer cluster is discussed. An approach that combines the advantages of relational and column-oriented DBMSs is proposed. A new type of distributed column indexes fragmented based on the domain-interval principle is introduced. The column indexes are auxiliary structures that are constantly stored in the distributed main memory of a computer cluster. To match the elements of a column index to the tuples of the original relation, surrogate keys are used. Resource hungry relational operations are performed on the corresponding column indexes rather than on the original relations of the database. As a result, a precomputation table is obtained. Using this table, the DBMS reconstructs the resulting relation. For basic relational operations on column indexes, methods for their parallel decomposition that do not require massive data exchanges between the processor nodes are proposed. This approach improves the class OLAP query performance by hundreds of times.},
	number = {3},
	urldate = {2024-01-04},
	journal = {Programming and Computer Software},
	author = {Ivanova, E. V. and Sokolinsky, L. B.},
	month = may,
	year = {2017},
	pages = {131--144},
	file = {ParallelProcessing.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\ParallelProcessing.pdf:application/pdf},
}

@misc{transaction_processing_performance_council_tpc_1995,
	address = {San Jose, California},
	type = {Benchmark},
	title = {{TPC} {Benchmark} {D}},
	author = {Transaction Processing Performance Council},
	year = {1995},
}

@inproceedings{szalay_sdss_2002,
	address = {New York, NY, USA},
	series = {{SIGMOD} '02},
	title = {The {SDSS} {Skyserver}: {Public} {Access} to the {Sloan} {Digital} {Sky} {Server} {Data}},
	isbn = {1-58113-497-5},
	url = {https://doi.org/10.1145/564691.564758},
	doi = {10.1145/564691.564758},
	abstract = {The SkyServer provides Internet access to the public Sloan Digital Sky Survey (SDSS) data for both astronomers and for science education. This paper describes the SkyServer goals and architecture. It also describes our experience operating the SkyServer on the Internet. The SDSS data is public and well-documented so it makes a good test platform for research on database algorithms and performance.},
	booktitle = {Proceedings of the 2002 {ACM} {SIGMOD} {International} {Conference} on {Management} of {Data}},
	publisher = {Association for Computing Machinery},
	author = {Szalay, Alexander S. and Gray, Jim and Thakar, Ani R. and Kunszt, Peter Z. and Malik, Tanu and Raddick, Jordan and Stoughton, Christopher and vandenBerg, Jan},
	year = {2002},
	note = {event-place: Madison, Wisconsin},
	pages = {570--581},
}

@misc{monetdb_bv_about_nodate,
	title = {About {Us}},
	url = {https://www.monetdb.org/about-us/},
	language = {en-us},
	urldate = {2024-01-04},
	author = {{MonetDB B.V.}},
	file = {Snapshot:C\:\\Users\\henri\\Zotero\\storage\\4C39QEQ2\\about-us.html:text/html},
}

@inproceedings{manegold_cache-conscious_2004,
	series = {{VLDB} '04},
	title = {Cache-{Conscious} {Radix}-{Decluster} {Projections}},
	isbn = {0-12-088469-0},
	url = {https://ir.cwi.nl/pub/11117/11117B.pdf},
	abstract = {As CPUs become more powerful with Moore's law and memory latencies stay constant, the impact of the memory access performance bottleneck continues to grow on relational operators like join, which can exhibit random access on a memory region larger than the hardware caches. While cache-conscious variants for various relational algorithms have been described, previous work has mostly ignored (the cost of) projection columns. However, real-life joins almost always come with projections, such that proper projection column manipulation should be an integral part of any generic join algorithm. In this paper, we analyze cache-conscious hash-join algorithms including projections on two storage schemes: N-ary Storage Model (NSM) and Decomposition Storage Model (DSM). It turns out, that the strategy of first executing the join and only afterwards dealing with the projection columns (i.e., post-projection) on DSM, in combination with a new finely tunable algorithm called Radix-Decluster, outperforms all previously reported projection strategies. To make this result generally applicable, we also outline how DSM Radix-Decluster can be integrated in a NSM-based RDBMS using projection indices.},
	urldate = {2024-01-04},
	booktitle = {Proceedings of the {Thirtieth} {International} {Conference} on {Very} {Large} {Data} {Bases} - {Volume} 30},
	publisher = {VLDB Endowment},
	author = {Manegold, Stefan and Boncz, Peter and Nes, Niels and Kersten, Martin},
	year = {2004},
	note = {Place: Toronto, Canada
[Author Manuscript]},
	pages = {684--695},
	file = {CacheConciousRadix.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\CacheConciousRadix.pdf:application/pdf},
}

@article{manegold_optimizing_2002,
	title = {Optimizing main-memory join on modern hardware},
	volume = {14},
	url = {https://ir.cwi.nl/pub/11143/11143B.pdf},
	number = {4},
	urldate = {2024-01-04},
	journal = {IEEE Transactions on Knowledge and Data Engineering},
	author = {Manegold, S. and Boncz, P. and Kersten, M.},
	year = {2002},
	note = {[Author Manuscript]},
	pages = {709--730},
	file = {OptimizingMainMemory.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\OptimizingMainMemory.pdf:application/pdf},
}

@inproceedings{zukowski_super-scalar_2006,
	address = {USA},
	series = {{ICDE} '06},
	title = {Super-{Scalar} {RAM}-{CPU} {Cache} {Compression}},
	isbn = {0-7695-2570-9},
	url = {https://ir.cwi.nl/pub/10892},
	doi = {10.1109/ICDE.2006.150},
	abstract = {High-performance data-intensive query processing tasks like OLAP, data mining or scientific data analysis can be severely I/O bound, even when high-end RAID storage systems are used. Compression can alleviate this bottleneck only if encoding and decoding speeds significantly exceed RAID I/O bandwidth. For this purpose, we propose three new versatile compression schemes (PDICT, PFOR, and PFOR-DELTA) that are specifically designed to extract maximum IPC from modern CPUs. We compare these algorithms with compression techniques used in (commercial) database and information retrieval systems. Our experiments on the MonetDB/X100 database system, using both DSM and PAX disk storage, show that these techniques strongly accelerate TPC-H performance to the point that the I/O bottleneck is eliminated.},
	urldate = {2024-01-04},
	booktitle = {Proceedings of the 22nd {International} {Conference} on {Data} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Zukowski, Marcin and Heman, Sandor and Nes, Niels and Boncz, Peter},
	year = {2006},
	note = {[Author Manuscript]},
	pages = {59},
	file = {SuperScalar.pdf:C\:\\Users\\henri\\Documents\\WS23_24\\LDE\\References\\SuperScalar.pdf:application/pdf},
}
